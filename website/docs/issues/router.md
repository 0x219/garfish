---
title: 路由问题
slug: /issues/router
order: 4
---

主应用路由目前仅支持为 `history` 模式，子应用路由的 `basename` 基于主应用，具体请参考[子应用 basename 配置](/napi/#basename)。

## 为什么主应用仅支持 history 模式？

- 目前 Garfish 是通过命名空间去避免应用间的路由发生冲突的。

- 主应用仅支持 `history` 模式的原因在于，`hash` 路由无法作为子应用的基础路由，从而可能导致主应用和子应用发生路由冲突。

## 根路由为什么不能作为子应用的激活条件？

- 有部分业务想将根路径作为子应用的激活条件，例如 `garfish.bytedance.net` 就触发子应用的渲染，由于目前子应用 **字符串的激活条件为最短匹配原则**，若子应用 `activeWhen: '/'` 表明 `'/xxx'` 都会激活。

- 之所以为最短匹配原则的原因在于，我们需要判断是否某个子应用的子路由被激活，如果可能是某个子应用的子路由，我们则可能激活该应用。

- 之所以有该限制是由于若某个子应用的激活条件为 `/`，则该应用的 `/xx` 都可能为改子应用的子路由，则可能与其他应用产生冲突，造成混乱。

## 子应用 render 函数拿到的 basename 是什么，有什么作用？

为什么推荐子应用拿通过 `provider` 传递过来的 `basename` 作为子应用的 `basename`，有些业务方在实际过程中直接通过约定形式直接在子应用增加 `basename` 已到达隔离的效果，但该使用方式可能导致主应用如果变更 `basename` 可能导致子应用无法一起变更生效。

例如：

1. 当前主应用访问到 `garfish.bytedance.net` 即可访问到该站点的主页，当前 `basename` 为 `/`，子应用 vue，访问路径为 `garfish.bytedance.net/vue`

2. 如果主应用想更改 `basename` 为 `/site`，则主应用的访问路径变为`garfish.bytedance.net/site`，子应用 vue 的访问路径变为 `garfish.bytedance.net/site/vue`

3. 所以推荐子应用直接将 `provider` 中传递的 `basename` 作为自身应用的基础路由，以保证主应用在变更路由之后，子应用的相对路径还是符合整体变化

:::note
微前端场景下，每个子应用可能都有自己的路由场景，为保证子应用间路由不冲突，Garfish 框架将配置的 `basename` + `子应用的 activeWhen` 匹配的路径作为子应用的基路径。

- 若在 Garfish 上配置 `basename: /demo`，子应用的激活路径为：`/vue2`，则子应用得到的激活路径为：`/demo/vue2`

- 若子应用的激活条件为函数，在每次发生路由变化时会通过校验子应用的激活函数若函数返回 `true` 表明符合当前激活条件将触发路由激活，

- Garfish 会将当前的路径传入激活函数分割以得到子应用的最长激活路径，并将 `basename` + `子应用最长激活路径传` 给子应用参数

- **子应用如果本身具备路由，在微前端的场景下，必须把 basename 作为子应用的基础路径，没有基础路由，子应用的路由可能与主应用和其他应用发生冲突**
  :::
